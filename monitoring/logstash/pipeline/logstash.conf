# Logstash Configuration for Bug Hunting Framework
input {
  # Filebeat input for application logs
  beats {
    port => 5044
    type => "application"
  }
  
  # Syslog input for system logs
  syslog {
    port => 5000
    type => "syslog"
  }
  
  # TCP input for structured logs
  tcp {
    port => 5001
    type => "structured"
    codec => json
  }
  
  # HTTP input for webhook logs
  http {
    port => 8080
    type => "webhook"
  }
}

filter {
  # Parse JSON logs
  if [type] == "structured" {
    json {
      source => "message"
    }
  }
  
  # Parse application logs
  if [type] == "application" {
    # Parse Django logs
    if [fields][service] == "backend" {
      grok {
        match => { "message" => "\[%{TIMESTAMP_ISO8601:timestamp}\] %{LOGLEVEL:level} %{GREEDYDATA:message}" }
      }
      
      # Extract request information
      if [message] =~ /^\[%{IP:client_ip}\] %{WORD:method} %{URIPATH:path} %{NUMBER:status_code}/ {
        grok {
          match => { "message" => "\[%{IP:client_ip}\] %{WORD:method} %{URIPATH:path} %{NUMBER:status_code} %{NUMBER:response_time}ms" }
        }
      }
      
      # Extract user information
      if [message] =~ /user_id=%{NUMBER:user_id}/ {
        grok {
          match => { "message" => ".*user_id=%{NUMBER:user_id}.*" }
        }
      }
      
      # Extract target information
      if [message] =~ /target=%{DATA:target}/ {
        grok {
          match => { "message" => ".*target=%{DATA:target}.*" }
        }
      }
      
      # Extract stage information
      if [message] =~ /stage=%{WORD:stage}/ {
        grok {
          match => { "message" => ".*stage=%{WORD:stage}.*" }
        }
      }
    }
    
    # Parse frontend logs
    if [fields][service] == "frontend" {
      grok {
        match => { "message" => "\[%{TIMESTAMP_ISO8601:timestamp}\] %{LOGLEVEL:level} %{GREEDYDATA:message}" }
      }
      
      # Extract user actions
      if [message] =~ /user_action=%{WORD:action}/ {
        grok {
          match => { "message" => ".*user_action=%{WORD:action}.*" }
        }
      }
      
      # Extract page views
      if [message] =~ /page=%{URIPATH:page}/ {
        grok {
          match => { "message" => ".*page=%{URIPATH:page}.*" }
        }
      }
    }
    
    # Parse stage container logs
    if [fields][service] =~ /stage_/ {
      grok {
        match => { "message" => "\[%{TIMESTAMP_ISO8601:timestamp}\] %{LOGLEVEL:level} %{GREEDYDATA:message}" }
      }
      
      # Extract tool information
      if [message] =~ /tool=%{WORD:tool}/ {
        grok {
          match => { "message" => ".*tool=%{WORD:tool}.*" }
        }
      }
      
      # Extract target information
      if [message] =~ /target=%{DATA:target}/ {
        grok {
          match => { "message" => ".*target=%{DATA:target}.*" }
        }
      }
      
      # Extract execution time
      if [message] =~ /execution_time=%{NUMBER:execution_time}/ {
        grok {
          match => { "message" => ".*execution_time=%{NUMBER:execution_time}.*" }
        }
      }
    }
  }
  
  # Parse syslog messages
  if [type] == "syslog" {
    grok {
      match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}" }
    }
    
    # Extract system metrics
    if [syslog_message] =~ /CPU usage: %{NUMBER:cpu_usage}%/ {
      grok {
        match => { "syslog_message" => "CPU usage: %{NUMBER:cpu_usage}%" }
      }
    }
    
    if [syslog_message] =~ /Memory usage: %{NUMBER:memory_usage}%/ {
      grok {
        match => { "syslog_message" => "Memory usage: %{NUMBER:memory_usage}%" }
      }
    }
    
    if [syslog_message] =~ /Disk usage: %{NUMBER:disk_usage}%/ {
      grok {
        match => { "syslog_message" => "Disk usage: %{NUMBER:disk_usage}%" }
      }
    }
  }
  
  # Parse webhook logs
  if [type] == "webhook" {
    json {
      source => "message"
    }
    
    # Extract webhook type
    if [webhook_type] {
      mutate {
        add_field => { "webhook_category" => "%{webhook_type}" }
      }
    }
  }
  
  # Add common fields
  mutate {
    add_field => {
      "environment" => "%{ENVIRONMENT:-production}"
      "cluster" => "%{CLUSTER:-bug-hunting}"
      "datacenter" => "%{DATACENTER:-primary}"
    }
  }
  
  # Add timestamp
  date {
    match => [ "timestamp", "ISO8601" ]
    target => "@timestamp"
  }
  
  # Add geoip for client IPs
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }
  
  # Add user agent parsing
  if [user_agent] {
    useragent {
      source => "user_agent"
      target => "user_agent_info"
    }
  }
  
  # Add severity mapping
  if [level] {
    translate {
      field => "level"
      destination => "severity"
      dictionary => {
        "DEBUG" => "low"
        "INFO" => "low"
        "WARNING" => "medium"
        "ERROR" => "high"
        "CRITICAL" => "critical"
      }
    }
  }
  
  # Add service categorization
  if [fields][service] {
    translate {
      field => "[fields][service]"
      destination => "service_category"
      dictionary => {
        "backend" => "api"
        "frontend" => "ui"
        "database" => "data"
        "redis" => "cache"
        "nginx" => "proxy"
        "prometheus" => "monitoring"
        "grafana" => "monitoring"
        "elasticsearch" => "search"
        "logstash" => "logging"
        "kibana" => "monitoring"
      }
    }
  }
  
  # Add business context
  if [user_id] {
    mutate {
      add_field => { "business_context" => "user_activity" }
    }
  }
  
  if [target] {
    mutate {
      add_field => { "business_context" => "bug_hunting" }
    }
  }
  
  if [stage] {
    mutate {
      add_field => { "business_context" => "workflow_execution" }
    }
  }
  
  # Remove sensitive fields
  mutate {
    remove_field => [ "password", "token", "secret", "key" ]
  }
  
  # Add log correlation ID
  if ![correlation_id] {
    mutate {
      add_field => { "correlation_id" => "%{uuid}" }
    }
  }
}

output {
  # Output to stdout for now since elasticsearch is not running
  stdout {
    codec => rubydebug
  }
  
  # Note: Elasticsearch, Prometheus, and AlertManager outputs are disabled
  # since those services are not currently running in the stack
} 