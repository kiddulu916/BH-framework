---
description: "Core project configuration and settings that define the project's technical stack, patterns, and conventions"
globs: "**/*"
alwaysApply: true
---
---
description: Bug-hunting-framework project configuration
globs: "**/*.*"
alwaysApply: true
---
# project-config.md
Last-Updated: 2025-01-27

## Project Goal
Build a scalable, secure, robust, and maintainable, fully automated full-stack application for bug hunting that supports ethical security testing, automated tool utilization, and comprehensive reporting capabilities.

## Tech Stack

### **Backend**
- **Framework**: Django + Django Ninja
  * REST API implementation with async support
  * Admin interface
  * Built-in security features
  * OpenAPI/Swagger documentation
  * Request/response validation with Pydantic
  * Standardized APIResponse pattern
  * Global exception handling

- **Database**: PostgreSQL with SQLAlchemy ORM
  * ACID compliance
  * Async operations with asyncpg
  * Advanced querying with SQLAlchemy 2.0
  * JSONB support
  * Full-text search
  * Connection pooling
  * Migration support with Alembic

- **Authentication**: JWT with HTTP-only cookies
  * Secure token storage in HTTP-only cookies
  * Access tokens with 30-minute default expiration
  * Refresh tokens with 7-day default expiration
  * Modern timezone-aware datetime handling
  * Token rotation and session management
  * Simple user management
  * Automatic user creation

- **Validation**: Pydantic
  * Request/response validation
  * Data type checking
  * Custom validators
  * Schema documentation
  * Business rules validation
  * Type hints

- **Testing**: Pytest + HTTPX with ASGITransport
  * Unit testing with async support
  * Integration testing with in-process ASGI app
  * API testing with real database integration
  * Mocking capabilities
  * Coverage reporting
  * Performance testing

- **Documentation**: Swagger/OpenAPI 3.0
  * API documentation
  * Interactive testing
  * Schema validation
  * Code generation
  * Version tracking
  * Security documentation

### **Frontend**
- **Framework**: Next.js 15.4.2
  * React 19.1.0
  * TypeScript 5.0
  * App Router and Server Components
  * Built-in optimization
  * Hot reloading for development

- **State Management**: Zustand
  * Zustand 5.0.6 for global state
  * Optimistic updates
  * Background refetching
  * Cache management

- **Styling**: Tailwind CSS 4.0
  * Utility-first CSS framework
  * PostCSS integration
  * Custom design system
  * Responsive design
  * Dark mode support

- **Animation**: Framer Motion 12.23.6
  * Component-level animations
  * Page transitions

- **Icons**: Lucide React 0.525.0
  * SVG-based icon library

- **HTTP Client**: Axios 1.10.0
  * Promise-based HTTP client
  * Request/response interceptors
  * Error handling
  * Request cancellation
  * Progress tracking

- **Development Tools**
  * ESLint 9.0 for linting
  * TypeScript for type checking
  * Hot reloading for development
  * Build optimization
  * Vitest for unit/integration testing
  * React Testing Library for component testing

### **Stage Containers**
- **Base Image**: Python 3.11-slim
  * Lightweight container images with minimal font dependencies
  * Comprehensive security tool integration
  * Standardized execution scripts with argument parsing
  * Environment-based configuration with `.env.template` files
  * Resource management with stage-specific limits
  * Health checks and dependency management

- **Security Tools**
  * **Passive Recon**: Sublist3r, Amass, Subfinder, Assetfinder, Gau, Waybackurls, Trufflehog
  * **Active Recon**: Nmap, Httpx, Nuclei, Subfinder, Amass, Naabu, Katana, Feroxbuster
  * **Vulnerability Scanning**: Nuclei, Nmap, Nikto, ZAP, Wapiti, Arachni
  * **Vulnerability Testing**: SQLMap, Hydra, Dirb, Gobuster, FFuf, Wfuzz, WhatWeb, WAFW00F
  * **AI/ML Integration**: PyTorch, TensorFlow, Transformers, Scikit-learn, OpenCV, Playwright

- **Execution Pattern**
  * Main script: `run_<stage_name>.py` with standardized argument parsing
  * Tool runners in `runners/` directory with modular design
  * Standardized API integration with JWT authentication
  * Comprehensive error handling and logging
  * Output directory structure: `/outputs/<target>/<stage>/`
  * Environment configuration with `.env.template` files

### **Containerization**
- **Docker Compose**: Multi-service orchestration
  * Core services: db, backend, frontend with health checks
  * Stage containers for each bug hunting stage with resource limits
  * Service dependencies: Database → Backend → Frontend → Stage containers
  * JWT rotation service for secure token management
  * Health checks and dependencies with configurable intervals
  * Resource management with memory and CPU limits

- **Service Architecture**
  * PostgreSQL database with persistent storage and health checks
  * Django backend with hot reloading and comprehensive monitoring
  * Next.js frontend with development mode and optimization
  * Custom network isolation with security hardening
  * Volume management for outputs and persistent data
  * Stage-specific resource allocation (2-4GB memory, 0.8-1.0 CPU cores)

### **Development Tools**
- **Version Control**: Git
  * Conventional commit messages
  * Branch protection
  * Pull request reviews
  * Automated testing

- **Code Quality**: 
  * Black for Python formatting
  * Flake8 for Python linting
  * MyPy for type checking
  * ESLint for JavaScript linting
  * Prettier for code formatting

- **Testing**: 
  * Pytest for Python testing
  * HTTPX for API testing
  * Coverage reporting
  * Integration testing
  * Performance testing

- **Documentation**: 
  * OpenAPI/Swagger for API docs
  * JSDoc for JavaScript documentation
  * README files for components
  * Architecture documentation

## AI/ML Integration

### **AI/ML Framework Integration**
- **Core Frameworks**: PyTorch 2.1.0+, TensorFlow 2.15.0+, Transformers 4.36.0+
- **Traditional ML**: Scikit-learn 1.3.0+, NumPy 1.24.0+, Pandas 2.1.0+
- **Computer Vision**: OpenCV 4.8.0+, Pillow 10.1.0+
- **Visualization**: Matplotlib 3.7.0+, Seaborn 0.12.0+, Plotly 5.15.0+
- **Browser Automation**: Playwright, Selenium, Chromium, Firefox

### **AI/ML Model Architecture**
- **Model Configuration**: Standardized `AIModelConfig` dataclass with confidence thresholds
- **Model Loading**: Optimized loading with caching and quantization support
- **Inference Pipeline**: Preprocessing → Model Prediction → Post-processing → Result Validation
- **Performance Optimization**: CPU optimization, batch processing, async operations
- **Resource Management**: Model caching, prediction caching, memory management

### **AI/ML Integration Patterns**
1. **Vulnerability Analysis**
   - **Input**: Payload strings, context data, HTTP requests/responses
   - **Processing**: Text preprocessing, feature extraction, model inference
   - **Output**: Vulnerability classification, confidence scores, recommendations

2. **Evidence Analysis**
   - **Input**: Screenshots, logs, network captures, tool outputs
   - **Processing**: Computer vision analysis, text extraction, anomaly detection
   - **Output**: Evidence classification, suspicious element detection, confidence scores

3. **Pattern Detection**
   - **Input**: Historical findings, attack patterns, vulnerability data
   - **Processing**: Clustering, anomaly detection, trend analysis
   - **Output**: Pattern identification, anomaly scores, predictive insights

4. **Report Generation**
   - **Input**: Raw findings, analysis results, stakeholder requirements
   - **Processing**: NLP analysis, content generation, visualization
   - **Output**: Executive summaries, technical reports, stakeholder communications

## API Architecture
- **Pattern**: Clean Architecture with dependency injection
  * Clear separation of concerns
  * Domain-driven design
  * SOLID principles
  * Interface-based design

- **Structure**: 
  * API Layer (Django Ninja routers)
  * Service Layer (Business logic)
  * Repository Layer (Data access with SQLAlchemy)
  * Model Layer (SQLAlchemy ORM entities)

- **Response Pattern**: Standardized APIResponse model
  * Consistent success/error response structure
  * Business logic errors return HTTP 200 with success=False
  * Framework errors use global exception handlers
  * All endpoints return APIResponse model

- **Error Handling**: 
  * Centralized error middleware
  * Global exception handlers for framework errors
  * Standardized error responses
  * Detailed error logging
  * Error correlation IDs
  * Error tracking and monitoring

- **Testing**: HTTPX with ASGITransport
  * In-process API testing
  * Real database integration
  * Async test support
  * Comprehensive test coverage
  * Performance testing

- **Logging**: 
  * Structured logging with correlation IDs
  * Log levels (DEBUG, INFO, WARNING, ERROR)
  * Log rotation and retention
  * Audit logging for security

## Environment Configuration

### **Standardized Environment Templates**
- **Template Structure**: `.env.template` files for all stages with comprehensive documentation
- **Stage-Specific Variables**: Tailored configuration for each stage's requirements
- **JWT Management**: Secure token generation, rotation, and validation across all services
- **Resource Limits**: Stage-specific memory and CPU allocation with monitoring
- **Health Checks**: Configurable health check patterns with retry logic
- **Logging**: Standardized logging configuration with correlation IDs

### **Stage-Specific Configurations**
1. **Vulnerability Scanning Stage**
   - Scanning types and tool configurations
   - Rate limiting and timeout settings
   - Tool path configurations

2. **Vulnerability Testing Stage**
   - AI/ML model configurations
   - Browser automation settings
   - Evidence collection parameters
   - Safety and ethical controls

3. **Comprehensive Reporting Stage**
   - Report format configurations
   - Template and output settings
   - Stakeholder communication settings

## Domain Architecture
- **Bug Hunting Domain**
  * Stage Management (passive_recon, active_recon, vuln_scan, vuln_test, kill_chain, comprehensive_reporting)
  * Workflow Management (target → stages → results)
  * Data Collection (raw outputs, parsed results)
  * Target Management (domains, IPs, scope)
  * AI/ML Integration (vulnerability analysis, evidence processing)

- **Bug Reporting Domain**
  * Report Templates
  * Report Generation
  * Platform Formatting
  * Export Management
  * Stakeholder Communication
  * AI-Powered Insights

- **User Management Domain**
  * Authentication (JWT tokens)
  * Profile Management
  * Session Handling
  * Platform Reference

- **Analytics Domain**
  * Performance Metrics
  * Success Statistics
  * Trend Analysis
  * Reporting Dashboards
  * AI-Powered Pattern Detection
  * Predictive Analytics

## Critical Patterns & Conventions

### **API Design**
- **RESTful endpoints**
  * Resource-based URLs (`/api/targets/`, `/api/results/`)
  * HTTP method semantics (GET, POST, PUT, DELETE)
  * Status code usage (200 for business logic, 422/404 for framework errors)
  * Error handling with standardized responses
  * Versioning via URL structure
  * OpenAPI/Swagger documentation

- **Standardized Response Model**
  ```python
  class APIResponse(BaseModel):
      success: bool
      message: str
      data: Optional[Dict[str, Any]]
      errors: Optional[List[str]]
  ```

- **JWT authentication**
  * Token management with HTTP-only cookies
  * Session handling with automatic refresh
  * Security headers enforcement
  * Token rotation and audit logging

- **Error handling**
  * Consistent response structure
  * Business logic errors vs framework errors
  * Validation error handling
  * Security error handling
  * System error handling

- **Input validation**
  * Pydantic schemas for all requests
  * Data type checking and conversion
  * Business rules validation
  * Custom validators for complex logic
  * Schema validation with detailed error messages

### **Database Patterns**
- **Model Inheritance**
  ```python
  class BaseModel(Base):
      __abstract__ = True
      id = Column(UUID(as_uuid=True), primary_key=True, default=uuid4)
      created_at = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
      updated_at = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))
  ```

- **Repository Pattern**
  ```python
  class BaseRepository:
      async def create(self, **kwargs) -> T
      async def get_by_id(self, id: UUID) -> Optional[T]
      async def list(self, filters: Dict, pagination: PaginationParams) -> List[T]
      async def update(self, id: UUID, **kwargs) -> Optional[T]
      async def delete(self, id: UUID) -> bool
  ```

- **Async Database Operations**
  ```python
  async with get_db_session() as session:
      repo = TargetRepository(session)
      service = TargetService(repo)
      result = await service.create_target(payload)
  ```

### **Testing Patterns**
- **HTTPX Integration Testing**
  ```python
  @pytest_asyncio.fixture
  async def api_client():
      transport = ASGITransport(app=application)
      async with AsyncClient(transport=transport, base_url="http://testserver") as client:
          yield client
  ```

- **Test Assertions**
  ```python
  # Success case
  assert response.status_code == 200
  data = response.json()
  assert data["success"] is True
  
  # Error case
  assert response.status_code == 200
  data = response.json()
  assert data["success"] is False
  assert "errors" in data
  ```

### **Stage Container Patterns**
- **Execution Script Structure**
  ```python
  def main():
      load_dotenv(dotenv_path=".env")
      parser = argparse.ArgumentParser(description="Stage Name Main Runner")
      parser.add_argument("--target", required=True, help="Target domain")
      parser.add_argument("--stage", default="stage_name", help="Stage name")
      args = parser.parse_args()
      
      # Stage execution logic
      setup_output_dirs(args.stage, args.target)
      run_tools(args.target)
      submit_results_to_api()
  ```

- **API Integration**
  ```python
  def save_parsed_to_db(tool_name: str, target_id: str, target: str, data: dict, api_url: str, jwt_token: str) -> bool:
      headers = {'Authorization': f'Bearer {jwt_token}'}
      payload = {'tool_name': tool_name, 'target_id': target_id, 'target': target, 'data': data}
      response = requests.post(f"{api_url}/parsed", json=payload, headers=headers)
      return response.status_code == 200
  ```

### **Docker Orchestration**
- **Service Dependencies**
  ```yaml
  backend:
    depends_on:
      db:
        condition: service_healthy
  frontend:
    depends_on:
      backend:
        condition: service_healthy
  ```

- **Health Checks**
  ```yaml
  healthcheck:
    test: ["CMD", "curl", "-f", "http://localhost:8000/health/"]
    interval: 30s
    timeout: 10s
    retries: 5
    start_period: 40s
  ```

## Development Standards

### Code Style
- **Python**: PEP 8 compliance with Black formatting
- **Type hints**: Comprehensive type hints throughout
- **Docstrings**: Google-style docstrings for all functions
- **Naming conventions**: snake_case for Python, camelCase for JavaScript
- **Import organization**: Grouped imports with isort

### Frontend Standards
- **Component Structure**: Functional components with hooks
- **State Management**: Zustand for global state
- **Styling**: Tailwind CSS with custom design system
- **Type Safety**: TypeScript for all components and functions
- **Error Boundaries**: Implement error boundaries for component error handling

### Testing Standards
- **Coverage**: 80% minimum test coverage
- **Test Organization**: Mirror source code structure
- **Fixtures**: Use pytest fixtures for test data
- **Mocking**: Mock external dependencies appropriately
- **Integration Tests**: Test complete workflows end-to-end

### Security Standards
- **Authentication**: JWT with secure token management
- **Input Validation**: Validate all inputs with Pydantic
- **SQL Injection**: Use parameterized queries with SQLAlchemy
- **XSS Prevention**: Sanitize all user inputs
- **CORS**: Configure CORS properly for cross-origin requests

### Performance Standards
- **Response Times**: < 1 second for most API endpoints
- **Database Optimization**: Use proper indexing and query optimization
- **Caching**: Implement caching for frequently accessed data
- **Async Operations**: Use async/await patterns throughout
- **Resource Management**: Monitor and optimize resource usage

## Monitoring and Maintenance

### **Performance Monitoring**
- **Response times**: Monitor API response times
- **Resource usage**: Monitor CPU, memory, and disk usage
- **Error rates**: Track error rates and types
- **Security events**: Monitor authentication and authorization events
- **User activity**: Track user activity and feature usage

### **Maintenance Tasks**
- **Security updates**: Regular dependency updates and security patches
- **Database maintenance**: Regular backups and optimization
- **Log rotation**: Implement log rotation and retention policies
- **Health monitoring**: Monitor service health and availability
- **Performance optimization**: Regular performance reviews and optimization

## Changelog
<!-- The agent prepends the latest summary here as a new list item after each VALIDATE phase -->
- [2025-01-27] [AI] [MAJOR] - Added comprehensive AI/ML Integration section with framework integration, model architecture, and integration patterns
- [2025-01-27] [AI] [MAJOR] - Added Environment Configuration section with standardized templates and stage-specific configurations
- [2025-01-27] [AI] [MAJOR] - Enhanced Stage Containers with comprehensive security tools, resource management, and health checks
- [2025-01-27] [AI] [MAJOR] - Updated Containerization with service dependencies, resource limits, and security hardening
- [2025-01-27] [AI] [MAJOR] - Enhanced Domain Architecture to include AI/ML integration and stakeholder communication
- [2025-01-27] [AI] [MAJOR] - Updated project configuration to reflect actual codebase patterns including specific tech stack versions, API response patterns, testing standards, and stage container patterns
- [2024-12-19] [AI] [MAJOR] - Updated JWT authentication with 30-minute access token expiration and modern datetime handling
- [2024-03-21] [AI] [MAJOR] - Updated project configuration with comprehensive security, testing, and deployment standards
- [2024-03-21] [AI] [MAJOR] - Added detailed domain architecture and critical patterns
- [2024-03-21] [AI] [MAJOR] - Enhanced tech stack with specific versions and features
- [2024-03-21] [AI] [MAJOR] - Added monitoring and maintenance sections

## Django Configuration
- **Project Name**: `api`
- **Settings Module**: `api.settings`
- **Apps Directory**: `core/` (registered in INSTALLED_APPS)
- **URL Configuration**: `api.urls.py`
- **Management Script**: `manage.py` (at root level)

### **Core Dependencies**
- **Framework**: Next.js 15.4.2
- **Language**: TypeScript 5.0
- **Package Manager**: npm (package-lock.json)
- **State Management**: Zustand 5.0.6
- **Animation**: Framer Motion 12.23.6
- **HTTP Client**: Axios 1.10.0

### **UI & Styling**
- **Styling**: Tailwind CSS 4.0
- **Icons**: Lucide React 0.525.0
- **Development**: Hot reloading enabled
- **Build**: Next.js build optimization

### **Development Tools**
- **Testing**: Vitest + React Testing Library
- **Linting**: ESLint 9.0
- **Type Checking**: TypeScript 5.0
- **Git Hooks**: Standard Git workflow
- **Code Quality**: ESLint configuration

### **Development Environment**
- **Local Server**: Next.js development server
- **Port**: 3000 (default)
- **Hot Reloading**: Enabled
- **Debug Tools**: Chrome DevTools
- **API Testing**: HTTPX integration testing

### **Version Control**
- **Repository**: Git
- **Branch Strategy**: Feature-based branching
- **Commit Convention**: Conventional Commits
- **Code Review**: Pull Requests

### **Documentation**
- **API**: OpenAPI/Swagger
- **Code**: JSDoc comments
- **Architecture**: Architecture Decision Records (ADRs)
- **Component**: README files

### **Performance & Monitoring**
- **Analytics**: Custom implementation
- **Error Tracking**: Logging and monitoring
- **Performance**: Built-in Next.js optimization
- **Logging**: Console logging

## Constraints
- You have a limited context window (Claude's limitation).
- You can make up to 25 tool calls per turn in Agent Composer mode.
- Adhere to the "Cursor AI Operating Instructions" provided separately.
- Prioritize code quality, maintainability, and security.
- Avoid making assumptions; ask clarifying questions when needed.

## Tokenization Settings
- Estimated chars-per-token: 3.5  
- Max tokens for the AI: 120 0000
- Plan for summary when **workflow-state.mdc** exceeds ~12 K chars.

---

## Changelog
<!-- The agent prepends the latest summary here as a new list item after each VALIDATE phase -->

## Critical Patterns & Conventions

### Tool/Library/Pattern Adoption
- All new tools, libraries, or major dependencies must be documented in the appropriate rule or architecture file.
- All new patterns must be cross-referenced with the current architecture and epic plans.
- Review all new tools/libraries/patterns for compatibility with existing project conventions before adoption.
- Ensure security, testing, and documentation requirements are met for all new additions.

### Checklist for Introducing New Project-Wide Patterns/Dependencies
- [ ] Cross-reference with architecture and epic plans
- [ ] Update this file and relevant rules/epics
- [ ] Document integration and usage patterns
- [ ] Add/expand tests and documentation as needed
- [ ] Review for security, performance, and maintainability

- [ ] Update this file and relevant rules/epics
- [ ] Document integration and usage patterns
- [ ] Add/expand tests and documentation as needed
- [ ] Review for security, performance, and maintainability
