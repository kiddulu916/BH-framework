---
description: Stage Container Patterns and Execution Rules
globs: stages/**/*.*
alwaysApply: true
---
# Stage Container Patterns and Execution Rules

## Stage Container Structure

### 1. **Directory Organization**
- **Location**: `stages/<stage_name>/`
- **Required files**: `Dockerfile`, `requirements.txt`, `run_<stage_name>.py`, `.env.template`
- **Optional files**: `runners/`, `tools/`, `utils.py`, `README.md`, `README_PHASE*.md`
- **Subdirectories**: `runners/` for modular components, `tools/` for custom tools

### 2. **Execution Script Pattern**
- **Main script**: `run_<stage_name>.py` (e.g., `run_passive_recon.py`)
- **Entry point**: Script must accept `--target` and `--stage` arguments
- **Structure**:
  ```python
  import argparse
  import os
  import json
  import requests
  from typing import Optional
  from dotenv import load_dotenv
  
  def main():
      load_dotenv(dotenv_path=".env")
      parser = argparse.ArgumentParser(description="Stage Name Main Runner")
      parser.add_argument("--target", required=True, help="Target domain")
      parser.add_argument("--stage", default="stage_name", help="Stage name")
      args = parser.parse_args()
      
      # Stage execution logic
      pass
  
  if __name__ == "__main__":
      main()
  ```

## Dockerfile Patterns

### 1. **Base Image and Structure**
- **Base Image**: `python:3.11-slim` for all stages
- **Multi-stage Builds**: Use `as base` for consistency
- **Security**: Non-root user execution (`appuser`)
- **Health Checks**: Built-in health monitoring

### 2. **System Dependencies Installation**
```dockerfile
# Install system dependencies and security tools
RUN apt-get update && apt-get install -y --no-install-recommends \
    # Core system tools
    curl \
    wget \
    git \
    unzip \
    build-essential \
    ca-certificates \
    python3-pip \
    python3-venv \
    python3-setuptools \
    python3-dev \
    python3-wheel \
    make \
    gcc \
    g++ \
    
    # Security and scanning tools (stage-specific)
    nmap \
    nikto \
    # ... additional tools
    
    # Font dependencies (minimal for smaller image)
    fonts-liberation \
    fonts-dejavu-core \
    fonts-dejavu-extra \
    
    # Cleanup
    && rm -rf /var/lib/apt/lists/*
```

### 3. **Go Tools Installation Pattern**
```dockerfile
# Install Go for Go-based security tools
RUN wget https://go.dev/dl/go1.24.4.linux-amd64.tar.gz \
    && tar -C /usr/local -xzf go1.24.4.linux-amd64.tar.gz \
    && rm go1.24.4.linux-amd64.tar.gz
ENV PATH="/usr/local/go/bin:${PATH}"
RUN go version

# Install Go-based security tools
RUN go install -v github.com/owasp-amass/amass/v4/...@master && \
    go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest && \
    go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest && \
    go install -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest
```

### 4. **Python Dependencies Installation**
```dockerfile
# Set working directory
WORKDIR /app

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Install additional Python packages (stage-specific)
RUN pip install --no-cache-dir \
    # AI/ML packages (for vuln_test)
    torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu \
    tensorflow-cpu \
    transformers[torch] \
    scikit-learn \
    # ... additional packages
```

### 5. **Environment and Tool Path Configuration**
```dockerfile
# Set environment variables
ENV PYTHONPATH=/app
ENV PATH="/app/tools:/usr/local/go/bin:${PATH}"

# Set tool paths (stage-specific)
ENV NMAP_PATH=/usr/bin/nmap
ENV NIKTO_PATH=/usr/bin/nikto
ENV NUCLEI_PATH=/root/go/bin/nuclei
ENV HTTPX_PATH=/root/go/bin/httpx
# ... additional tool paths

# Create non-root user for security
RUN groupadd -r appuser && useradd -r -g appuser appuser
RUN chown -R appuser:appuser /app /app/outputs
USER appuser

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:8000/health/', timeout=5)" || exit 1

# Set entry point
ENTRYPOINT ["python", "run_<stage_name>.py"]
```

### 6. **Stage-Specific Dockerfile Features**

#### **Vulnerability Testing Stage (vuln_test)**
- **AI/ML Support**: TensorFlow, PyTorch, Transformers, Scikit-learn
- **Browser Automation**: Chromium, Firefox, Playwright, Selenium
- **Evidence Collection**: Screenshots, video recording capabilities
- **Resource Requirements**: 4GB memory, 1.0 CPU cores

#### **Vulnerability Scanning Stage (vuln_scan)**
- **Multiple Scanning Tools**: Nuclei, Nmap, Nikto, ZAP, Wapiti, Arachni
- **OWASP ZAP Integration**: Full ZAP installation and configuration
- **Resource Requirements**: 2GB memory, 0.8 CPU cores

#### **Comprehensive Reporting Stage (comprehensive_reporting)**
- **Report Generation**: Pandoc, wkhtmltopdf, ReportLab, WeasyPrint
- **Visualization**: Matplotlib, Seaborn, Plotly, Dash
- **Node.js Tools**: Puppeteer for advanced reporting
- **Resource Requirements**: 4GB memory, 1.0 CPU cores

## Environment Configuration Patterns

### 1. **Environment File Template Structure**
```bash
# Backend API Configuration
BACKEND_API_URL=http://backend:8000/api/results/stage-name
BACKEND_JWT_TOKEN=your_jwt_token_here

# JWT Configuration (must match backend)
JWT_SECRET=your_jwt_secret_here
JWT_ALGORITHM=HS256

# Stage Configuration
STAGE_NAME=stage_name
TARGET=example.com
STAGE_TIMEOUT_SECONDS=1800

# Output Configuration
OUTPUT_DIR=/app/outputs
LOG_DIR=/app/logs

# Stage-specific Configuration
# ... stage-specific variables

# Font Configuration (minimal fonts for smaller image size)
FONT_PACKAGES=fonts-liberation,fonts-dejavu-core,fonts-dejavu-extra

# Resource Limits
MAX_MEMORY_MB=2048
MAX_CPU_CORES=0.8

# Logging Configuration
LOG_LEVEL=INFO
LOG_FORMAT=%(asctime)s - %(name)s - %(levelname)s - %(message)s
LOG_FILE=stage_name.log

# Health Check Configuration
HEALTH_CHECK_URL=http://localhost:8000/health/
HEALTH_CHECK_INTERVAL=30
HEALTH_CHECK_TIMEOUT=10
HEALTH_CHECK_RETRIES=3
```

### 2. **JWT Token Generation**
```bash
# Generate JWT for stage
python stages/utils/generate_jwt.py --sub stage_name_stage --env-path stages/stage_name/.env
```

## API Integration Patterns

### 1. **JWT Authentication**
- **Environment variable**: `BACKEND_JWT_TOKEN`
- **Usage**: Include in all API requests
- **Pattern**:
  ```python
  jwt_token = os.environ.get("BACKEND_JWT_TOKEN", "")
  headers = {
      'Content-Type': 'application/json',
      'Authorization': f'Bearer {jwt_token}'
  }
  ```

### 2. **API URL Construction**
- **Base URL**: `BACKEND_API_URL` environment variable
- **Pattern**: Construct URLs dynamically
- **Example**:
  ```python
  api_url = os.environ.get("BACKEND_API_URL", "http://backend:8000/api/results/stage-name")
  base_url = api_url.split('/results/')[0] if '/results/' in api_url else api_url.rstrip('/')
  targets_url = f"{base_url}/targets/"
  ```

### 3. **Result Submission**
- **Raw data**: Submit tool output files
- **Parsed data**: Submit structured JSON results
- **Pattern**:
  ```python
  def save_raw_to_db(tool_name: str, target_id: str, file_path: str, api_url: str, jwt_token: str) -> bool:
      try:
          with open(file_path, 'rb') as f:
              files = {'file': f}
              data = {'tool_name': tool_name, 'target_id': target_id}
              response = requests.post(f"{api_url}/raw", files=files, data=data, headers=headers)
              return response.status_code == 200
      except Exception as e:
          print(f"[ERROR] Failed to save raw data: {e}")
          return False
  
  def save_parsed_to_db(tool_name: str, target_id: str, target: str, data: dict, api_url: str, jwt_token: str) -> bool:
      try:
          payload = {
              'tool_name': tool_name,
              'target_id': target_id,
              'target': target,
              'data': data
          }
          response = requests.post(f"{api_url}/parsed", json=payload, headers=headers)
          return response.status_code == 200
      except Exception as e:
          print(f"[ERROR] Failed to save parsed data: {e}")
          return False
  ```

## Output Directory Structure

### 1. **Standard Directory Layout**
- **Target directory**: `/outputs/<target>/`
- **Raw outputs**: `/outputs/<target>/raw/`
- **Parsed outputs**: `/outputs/<target>/parsed/`
- **Stage-specific**: `/outputs/<target>/<stage_name>/`

### 2. **File Naming Conventions**
- **Raw files**: `<tool_name>.<extension>`
- **Parsed files**: `<tool_name>_<data_type>.txt` or `<tool_name>_<data_type>.json`
- **Examples**:
  - `sublist3r.txt`
  - `amass.json`
  - `subfinder_subdomains.txt`

### 3. **Directory Setup Function**
- **Pattern**: Use consistent directory setup
- **Implementation**:
  ```python
  def setup_output_dirs(stage: str, target: str):
      target_dir = os.path.join("/outputs", target)
      raw_dir = os.path.join(target_dir, "raw")
      parsed_dir = os.path.join(target_dir, "parsed")
      
      os.makedirs(target_dir, exist_ok=True)
      os.makedirs(raw_dir, exist_ok=True)
      os.makedirs(parsed_dir, exist_ok=True)
      
      return {"target_dir": target_dir, "raw_dir": raw_dir, "parsed_dir": parsed_dir}
  ```

## Tool Runner Patterns

### 1. **Tool Runner Structure**
- **Location**: `stages/<stage_name>/runners/`
- **Pattern**: Individual runner for each tool
- **Structure**:
  ```python
  def run_tool_name(target: str, output_dir: str) -> dict:
      """
      Run tool_name against target and return results.
      
      Args:
          target: Target domain/IP
          output_dir: Directory to save outputs
          
      Returns:
          Dictionary containing tool results
      """
      try:
          # Tool execution logic
          result = execute_tool(target)
          
          # Save raw output
          raw_file = os.path.join(output_dir, f"tool_name_{target}.txt")
          with open(raw_file, 'w') as f:
              f.write(result['raw_output'])
          
          return result
      except Exception as e:
          print(f"[ERROR] Tool execution failed: {e}")
          return {"error": str(e)}
  ```

### 2. **Error Handling**
- **Tool failures**: Don't halt entire stage execution
- **Logging**: Use consistent log format
- **Pattern**:
  ```python
  try:
      tool_results = run_tool(target, output_dir)
      # Process results
  except Exception as e:
      print(f"[ERROR] Tool runner failed: {e}")
      summary["tool_name"] = {"runner": False, "error": str(e)}
  ```

## Target Management

### 1. **Target ID Resolution**
- **Pattern**: Get or create target in backend
- **Implementation**:
  ```python
  def get_target_id(domain: str, api_url: str, jwt_token: str) -> Optional[str]:
      try:
          # Try to get existing target
          response = requests.get(f"{targets_url}?value={domain}", headers=headers)
          if response.status_code == 200:
              data = response.json()
              if data.get('success') and data.get('data'):
                  targets = data['data'].get('targets', []) or data['data'].get('items', [])
                  if targets:
                      return targets[0].get('id')
          
          # Create target if not exists
          return create_target_if_not_exists(domain, api_url, jwt_token)
      except Exception as e:
          print(f"[ERROR] Failed to get target ID: {e}")
          return None
  ```

### 2. **Target Creation**
- **Pattern**: Create target automatically if not exists
- **Payload structure**:
  ```python
  payload = {
      "target": domain,
      "domain": domain,
      "status": "ACTIVE",  # Uppercase enum value
      "platform": "BUGBOUNTY",  # Uppercase enum value
      "is_primary": True
  }
  ```

## Environment Configuration

### 1. **Required Environment Variables**
- **API configuration**: `BACKEND_API_URL`, `BACKEND_JWT_TOKEN`
- **Tool paths**: Tool-specific paths (e.g., `AMASS_PATH`, `SUBFINDER_PATH`)
- **Wordlists**: Path to wordlist directories

### 2. **Environment Loading**
- **Pattern**: Use python-dotenv
- **Implementation**:
  ```python
  from dotenv import load_dotenv
  
  def main():
      load_dotenv(dotenv_path=".env")
      # Access environment variables
      api_url = os.environ.get("BACKEND_API_URL")
      jwt_token = os.environ.get("BACKEND_JWT_TOKEN")
  ```

## Execution Summary

### 1. **Summary Tracking**
- **Pattern**: Track success/failure for each tool
- **Structure**:
  ```python
  summary = {}
  
  # For each tool
  try:
      results = run_tool(target, output_dir)
      raw_ok = save_raw_to_db(tool_name, target_id, raw_file, api_url, jwt_token)
      parsed_ok = save_parsed_to_db(tool_name, target_id, target, results, api_url, jwt_token)
      summary[tool_name] = {"runner": True, "raw_api": raw_ok, "parsed_api": parsed_ok}
  except Exception as e:
      summary[tool_name] = {"runner": False, "error": str(e)}
  ```

### 2. **Final Summary**
- **Pattern**: Print summary at end of execution
- **Implementation**:
  ```python
  print("\n=== Execution Summary ===")
  for tool, status in summary.items():
      if status.get("runner"):
          print(f"✅ {tool}: Runner OK, Raw API: {status.get('raw_api', False)}, Parsed API: {status.get('parsed_api', False)}")
      else:
          print(f"❌ {tool}: {status.get('error', 'Unknown error')}")
  ```

## Docker Configuration

### 1. **Dockerfile Requirements**
- **Base image**: Use lightweight Python image
- **Tool installation**: Install required tools
- **Working directory**: Set to `/app`
- **Entry point**: Set to main execution script

### 2. **Dockerfile Pattern**
  ```dockerfile
  FROM python:3.11-slim
  
  # Install system dependencies
  RUN apt-get update && apt-get install -y \
      tool1 tool2 tool3 \
      && rm -rf /var/lib/apt/lists/*
  
  WORKDIR /app
  
  # Copy requirements and install Python dependencies
  COPY requirements.txt .
  RUN pip install --no-cache-dir -r requirements.txt
  
  # Copy stage files
  COPY . .
  
  # Set entry point
  CMD ["python", "run_stage_name.py"]
  ```

## Testing Patterns

### 1. **Stage Testing**
- **Location**: `stages/<stage_name>/test_<stage_name>.py`
- **Pattern**: Test individual tool runners
- **Mock external dependencies**: Mock API calls and file operations

### 2. **Integration Testing**
- **Test with real backend**: Use test backend instance
- **Validate outputs**: Check file creation and API submission
- **Error scenarios**: Test with invalid inputs and network failures

