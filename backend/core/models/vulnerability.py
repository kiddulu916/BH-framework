"""
Vulnerability models for storing vulnerability scanning results.

This module defines the Vulnerability and VulnerabilityFinding models
which store the results of vulnerability scanning and testing activities.
"""

from typing import List, Optional
from uuid import UUID

from sqlalchemy import Column, String, Text, Boolean, Enum, ForeignKey, Index, Integer, Float
from sqlalchemy.dialects.postgresql import UUID as PGUUID, JSONB
from sqlalchemy.orm import relationship

from .base import BaseModel
import enum


class VulnerabilitySeverity(enum.Enum):
    """Enumeration for vulnerability severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityStatus(enum.Enum):
    """Enumeration for vulnerability status."""
    OPEN = "open"
    VERIFIED = "verified"
    FALSE_POSITIVE = "false_positive"
    FIXED = "fixed"
    WONT_FIX = "wont_fix"
    DUPLICATE = "duplicate"


class VulnerabilityType(enum.Enum):
    """Enumeration for vulnerability types."""
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    CSRF = "csrf"
    SSRF = "ssrf"
    RCE = "rce"
    LFI = "lfi"
    RFI = "rfi"
    IDOR = "idor"
    BROKEN_AUTH = "broken_auth"
    SENSITIVE_DATA_EXPOSURE = "sensitive_data_exposure"
    SECURITY_MISCONFIGURATION = "security_misconfiguration"
    INSECURE_DESERIALIZATION = "insecure_deserialization"
    COMPONENTS_WITH_KNOWN_VULNERABILITIES = "components_with_known_vulnerabilities"
    INSUFFICIENT_LOGGING = "insufficient_logging"
    OTHER = "other"


class Vulnerability(BaseModel):
    """
    Vulnerability model representing vulnerability scanning results.
    
    This model stores the overall results of vulnerability scanning
    activities performed against discovered services and applications.
    """
    
    __tablename__ = "vulnerabilities"
    __table_args__ = (
        Index('idx_vulnerabilities_target', 'target_id'),
        Index('idx_vulnerabilities_execution', 'execution_id'),
        Index('idx_vulnerabilities_created', 'created_at'),
        {'schema': 'public'}
    )
    
    # Vulnerability identification
    execution_id = Column(String(255), nullable=False, index=True)  # Link to workflow execution
    scan_type = Column(String(100), nullable=True)  # Type of vulnerability scan
    
    # Scan details
    tools_used = Column(JSONB, nullable=True)  # List of tools used and their versions
    configuration = Column(JSONB, nullable=True)  # Configuration used for the scan
    scan_targets = Column(JSONB, nullable=True)  # Targets that were scanned
    
    # Results summary
    total_findings = Column(Integer, default=0, nullable=False)
    critical_findings = Column(Integer, default=0, nullable=False)
    high_findings = Column(Integer, default=0, nullable=False)
    medium_findings = Column(Integer, default=0, nullable=False)
    low_findings = Column(Integer, default=0, nullable=False)
    info_findings = Column(Integer, default=0, nullable=False)
    
    # Raw results
    raw_output = Column(JSONB, nullable=True)  # Raw tool outputs
    processed_data = Column(JSONB, nullable=True)  # Processed and normalized data
    
    # Execution metadata
    execution_time = Column(String(50), nullable=True)  # Total execution time
    errors = Column(JSONB, nullable=True)  # Any errors encountered
    
    # Relationships
    target_id = Column(PGUUID(as_uuid=True), ForeignKey("public.targets.id"), nullable=False)
    target = relationship("Target", back_populates="vulnerabilities")
    
    # Vulnerability findings
    findings = relationship("VulnerabilityFinding", back_populates="vulnerability", cascade="all, delete-orphan")
    
    def __repr__(self) -> str:
        """String representation of the vulnerability scan result."""
        return f"<Vulnerability(target_id='{self.target_id}', total_findings={self.total_findings})>"
    
    def to_dict(self) -> dict:
        """Convert vulnerability scan result to dictionary."""
        base_dict = super().to_dict()
        return {
            **base_dict,
            'execution_id': self.execution_id,
            'scan_type': self.scan_type,
            'tools_used': self.tools_used,
            'configuration': self.configuration,
            'scan_targets': self.scan_targets,
            'total_findings': self.total_findings,
            'critical_findings': self.critical_findings,
            'high_findings': self.high_findings,
            'medium_findings': self.medium_findings,
            'low_findings': self.low_findings,
            'info_findings': self.info_findings,
            'raw_output': self.raw_output,
            'processed_data': self.processed_data,
            'execution_time': self.execution_time,
            'errors': self.errors,
            'target_id': str(self.target_id),
        }


class VulnerabilityFinding(BaseModel):
    """
    VulnerabilityFinding model representing individual vulnerability findings.
    
    This model stores detailed information about individual vulnerabilities
    discovered during scanning activities.
    """
    
    __tablename__ = "vulnerability_findings"
    __table_args__ = (
        Index('idx_vulnerability_findings_title', 'title'),
        Index('idx_vulnerability_findings_type', 'vuln_type'),
        Index('idx_vulnerability_findings_severity', 'severity'),
        Index('idx_vulnerability_findings_status', 'status'),
        Index('idx_vulnerability_findings_cve', 'cve_id'),
        Index('idx_vulnerability_findings_host', 'affected_host'),
        Index('idx_vulnerability_findings_verified', 'is_verified'),
        Index('idx_vulnerability_findings_vulnerability', 'vulnerability_id'),
        {'schema': 'public'}
    )
    
    # Finding identification
    title = Column(String(500), nullable=False, index=True)  # Vulnerability title
    vuln_type = Column(Enum(VulnerabilityType), nullable=False, default=VulnerabilityType.OTHER, index=True)
    severity = Column(Enum(VulnerabilitySeverity), nullable=False, default=VulnerabilitySeverity.INFO, index=True)
    status = Column(Enum(VulnerabilityStatus), nullable=False, default=VulnerabilityStatus.OPEN, index=True)
    
    # Vulnerability details
    description = Column(Text, nullable=True)  # Detailed description
    cve_id = Column(String(50), nullable=True, index=True)  # CVE identifier if applicable
    cvss_score = Column(Float, nullable=True)  # CVSS score if available
    cvss_vector = Column(String(100), nullable=True)  # CVSS vector string
    
    # Affected components
    affected_host = Column(String(255), nullable=True, index=True)  # Affected host
    affected_port = Column(Integer, nullable=True)  # Affected port
    affected_service = Column(String(255), nullable=True)  # Affected service
    affected_url = Column(String(1000), nullable=True)  # Affected URL if web application
    
    # Technical details
    proof_of_concept = Column(Text, nullable=True)  # Proof of concept
    remediation = Column(Text, nullable=True)  # Remediation steps
    references = Column(JSONB, nullable=True)  # References and links
    
    # Detection metadata
    detection_tool = Column(String(255), nullable=True)  # Tool that detected this
    detection_method = Column(String(255), nullable=True)  # Method used for detection
    confidence = Column(String(50), nullable=True)  # Confidence level
    
    # Verification
    is_verified = Column(Boolean, default=False, nullable=False, index=True)  # Whether manually verified
    verification_notes = Column(Text, nullable=True)  # Notes from verification
    
    # Additional information
    tags = Column(JSONB, nullable=True)  # Tags for categorization
    notes = Column(Text, nullable=True)  # Additional notes
    
    # Relationships
    vulnerability_id = Column(PGUUID(as_uuid=True), ForeignKey("public.vulnerabilities.id"), nullable=False)
    vulnerability = relationship("Vulnerability", back_populates="findings")
    
    def __repr__(self) -> str:
        """String representation of the vulnerability finding."""
        return f"<VulnerabilityFinding(title='{self.title}', severity='{self.severity.value}', status='{self.status.value}')>"
    
    def to_dict(self) -> dict:
        """Convert vulnerability finding to dictionary."""
        base_dict = super().to_dict()
        return {
            **base_dict,
            'title': self.title,
            'vuln_type': self.vuln_type.value,
            'severity': self.severity.value,
            'status': self.status.value,
            'description': self.description,
            'cve_id': self.cve_id,
            'cvss_score': self.cvss_score,
            'cvss_vector': self.cvss_vector,
            'affected_host': self.affected_host,
            'affected_port': self.affected_port,
            'affected_service': self.affected_service,
            'affected_url': self.affected_url,
            'proof_of_concept': self.proof_of_concept,
            'remediation': self.remediation,
            'references': self.references,
            'detection_tool': self.detection_tool,
            'detection_method': self.detection_method,
            'confidence': self.confidence,
            'is_verified': self.is_verified,
            'verification_notes': self.verification_notes,
            'tags': self.tags,
            'vulnerability_id': str(self.vulnerability_id),
        }
    
    @property
    def is_critical_or_high(self) -> bool:
        """Check if finding is critical or high severity."""
        return self.severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH]
    
    @property
    def display_severity(self) -> str:
        """Get display severity with color coding."""
        severity_colors = {
            VulnerabilitySeverity.CRITICAL: "ğŸ”´",
            VulnerabilitySeverity.HIGH: "ğŸŸ ",
            VulnerabilitySeverity.MEDIUM: "ğŸŸ¡",
            VulnerabilitySeverity.LOW: "ğŸŸ¢",
            VulnerabilitySeverity.INFO: "ğŸ”µ",
        }
        return f"{severity_colors.get(self.severity, 'âšª')} {self.severity.value.upper()}" 