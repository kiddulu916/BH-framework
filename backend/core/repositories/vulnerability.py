"""
Vulnerability repositories.

This module provides the VulnerabilityRepository and VulnerabilityFindingRepository
classes which handle all database operations related to vulnerabilities.
"""

from typing import List, Optional
from uuid import UUID

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from sqlalchemy.future import select
from sqlalchemy import func

from ..models.vulnerability import Vulnerability, VulnerabilityFinding, VulnerabilitySeverity, VulnerabilityStatus
from .base import BaseRepository


class VulnerabilityRepository(BaseRepository):
    """Repository for Vulnerability model operations."""
    
    def __init__(self, session: AsyncSession):
        super().__init__(session, Vulnerability)
    
    async def get_by_target(self, target_id: UUID) -> List[Vulnerability]:
        """Get all vulnerability results for a target."""
        return await self.list(filters={'target_id': target_id}, order_by=['created_at'])
    
    async def get_by_execution_id(self, execution_id: str) -> Optional[Vulnerability]:
        """Get vulnerability result by execution ID."""
        return await self.find_one({'execution_id': execution_id})
    
    async def create_with_findings(self, findings: List[dict], **kwargs) -> Vulnerability:
        """
        Create a vulnerability record with its findings.
        
        Args:
            findings: List of finding dictionaries
            **kwargs: Vulnerability data
            
        Returns:
            Created vulnerability record
        """
        # Create the vulnerability record
        vulnerability = await self.create(**kwargs)
        
        # Create the findings
        finding_repo = VulnerabilityFindingRepository(self.session)
        for finding_data in findings:
            finding_data['vulnerability_id'] = vulnerability.id
            await finding_repo.create(**finding_data)
        
        return vulnerability

    async def get_by_workflow_id(self, workflow_id: UUID):
        """Get all vulnerability records for a workflow ID with findings preloaded."""
        stmt = (
            select(Vulnerability)
            .options(selectinload(Vulnerability.findings))
            .where(Vulnerability.execution_id == str(workflow_id))
            .order_by(Vulnerability.created_at)
        )
        
        result = await self.session.execute(stmt)
        return result.scalars().all()

    async def count_by_target(self, target_id: UUID) -> int:
        """Count vulnerability results for a target."""
        return await self.count(filters={'target_id': target_id})

    async def get_latest_by_target(self, target_id: UUID) -> Optional[Vulnerability]:
        """Get the latest vulnerability result for a target."""
        query = select(self.model_class).where(
            self.model_class.target_id == target_id
        ).order_by(self.model_class.created_at.desc()).limit(1)
        result = await self.session.execute(query)
        return result.scalar_one_or_none()

    async def list_by_target_with_pagination(self, target_id: UUID, page: int = 1, per_page: int = 10, severity: Optional[str] = None):
        """Return paginated vulnerability results for a target, optionally filtered by severity."""
        offset = (page - 1) * per_page
        
        if severity:
            # If filtering by severity, we need to join with VulnerabilityFinding
            from sqlalchemy.orm import selectinload
            from ..models.vulnerability import VulnerabilitySeverity
            
            # Convert severity string to enum
            try:
                severity_enum = VulnerabilitySeverity(severity.lower())
            except ValueError:
                # If invalid severity, return empty results
                return [], 0
            
            # Query vulnerabilities that have findings with the specified severity
            query = (
                select(self.model_class)
                .options(selectinload(self.model_class.findings))
                .join(self.model_class.findings)
                .where(
                    self.model_class.target_id == target_id,
                    self.model_class.findings.any(severity=severity_enum)
                )
                .order_by(self.model_class.created_at.desc())
                .offset(offset)
                .limit(per_page)
            )
            
            # Count query for pagination
            count_query = (
                select(func.count(self.model_class.id))
                .join(self.model_class.findings)
                .where(
                    self.model_class.target_id == target_id,
                    self.model_class.findings.any(severity=severity_enum)
                )
            )
        else:
            # No severity filter, simple query
            query = (
                select(self.model_class)
                .options(selectinload(self.model_class.findings))
                .where(self.model_class.target_id == target_id)
                .order_by(self.model_class.created_at.desc())
                .offset(offset)
                .limit(per_page)
            )
            
            # Count query for pagination
            count_query = (
                select(func.count(self.model_class.id))
                .where(self.model_class.target_id == target_id)
            )
        
        result = await self.session.execute(query)
        items = result.scalars().all()
        
        count_result = await self.session.execute(count_query)
        total = count_result.scalar_one()
        
        return items, total

    async def count_by_workflow(self, workflow_id: UUID) -> int:
        """Count vulnerability results for a workflow."""
        return await self.count(filters={'execution_id': str(workflow_id)})


class VulnerabilityFindingRepository(BaseRepository):
    """Repository for VulnerabilityFinding model operations."""
    
    def __init__(self, session: AsyncSession):
        super().__init__(session, VulnerabilityFinding)
    
    async def get_by_vulnerability(self, vulnerability_id: UUID) -> List[VulnerabilityFinding]:
        """Get all findings for a vulnerability result."""
        return await self.list(filters={'vulnerability_id': vulnerability_id}, order_by=['created_at'])
    
    async def get_by_severity(self, severity: VulnerabilitySeverity) -> List[VulnerabilityFinding]:
        """Get all findings by severity."""
        return await self.list(filters={'severity': severity}, order_by=['created_at'])
    
    async def get_by_status(self, status: VulnerabilityStatus) -> List[VulnerabilityFinding]:
        """Get all findings by status."""
        return await self.list(filters={'status': status}, order_by=['created_at'])
    
    async def get_verified_findings(self) -> List[VulnerabilityFinding]:
        """Get all verified findings."""
        return await self.list(filters={'is_verified': True}, order_by=['created_at'])
    
    async def get_critical_and_high_findings(self) -> List[VulnerabilityFinding]:
        """Get all critical and high severity findings."""
        return await self.list(
            filters={'severity': [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH]},
            order_by=['created_at']
        ) 